= Architecture

Commodore's operation can be separated into three rough stages: dependency
fetching, catalog compilation, and secrets management.

Apart from these stages of operation, we also document other architectural
choices in this page.

== Dependency fetching

Currently, the first part of Commodore's operation revolves around fetching
all the dependencies required to compile a catalog.
Dependency fetching is implemented using Git repositories and `git clone` and
calls to the Lieutenant API.

Commodore fetches the following dependencies:

* Cluster facts from Lieutenant API
* Global configuration
* Tenant configuration
* Components as discovered in global and tenant configuration
* Jsonnet libraries as described in the
  <<_configuration_hierarchy,configuration hierarchy>>

=== Component discovery

By default, Commodore searches all the classes in the global and tenant
configurations for includes which start with `components.`.
All of these includes are considered to be components that need to be fetched.
Unless instructed otherwise, Commodore will fetch components from subfolder
`commodore-components` in the
xref:reference/cli.adoc#_catalog_compile[global Git base].

The file `commodore.yml` in the root of the Global configuration repository
can be used to override the repository autodiscovery for components.
The file must contain a key `components` which holds an array of dictionaries
with keys `name` and `url`.
Each array entry specifies the repository URL of a single component.
A sample `commodore.yml` can be found below.

.commodore.yml
[source,yaml]
--
components:
- name: argocd
  url: https://github.com/projectsyn/component-argocd.git
- name: metrics-server
  url: https://github.com/projectsyn/component-metrics-server.git
--

Additionally, component repositories can be overridden in the hierarchy in
parameter `parameters.component_versions.<component-name>` by setting the key
`url`.
This can't be used as a replacement for globally overriding the default
location in `commodore.yml`, as the component must be discoverable without
having to parse the Kapitan inventory.
However, this mechanism can be used to configure a subset of managed clusters
to use a fork of a component.

[source,yaml]
--
parameters:
  component_versions:
    argocd:
      url: https://github.com/projectsyn/component-argocd/
--

=== Component versioning

As described in the xref:reference/concepts.adoc[Commodore concepts],
component versions and remote repository locations can be specified in the
configuration hierarchy.
Component versions are tracked in the inventory in key `version` under
parameter `component_versions.<component-name>` and default to the component
repository's default branch.

An example:

[source,yaml]
--
parameters:
  component_versions:
    argocd:
      version: v1.0.0
--

Reusing the <<_configuration_hierarchy,configuration hierarchy>> for
specifying the component versions allows tight integration of component
version management with the rest of the configuration.

After cloning component repositories, all components will be checked out on
the repository's default branch.
Commodore will then explicitly check out the version specified in the
inventory for any components that specify a version.
The version specification is parsed from the inventory using Kapitan's
inventory parsing, allowing the version to be overridden at any point in the
configuration hierarchy.

== Catalog Compilation

Commodore uses https://kapitan.dev[Kapitan] to compile the cluster catalog.
Kapitan is called with a few options enabled.
Most importantly, Kapitan is configured to support fetching dependencies of
components, such as Helm charts.
Further, Kapitan is configured with an extended search path to support
component libraries and the builtin `commodore.libjsonnet`.
Finally, Kapitan is also configured to search for secret reference files in
`catalog/refs` during compilation.
See section <<_secrets_management>> for more details on the secrets management
implemented with Commodore and Kapitan.

=== Postprocessing filters

After running Kapitan, Commodore applies postprocessing filters to the output
of Kapitan.
Postprocessing filters are defined in components and allow components to
describe transformations that should be applied to the rendered manifests of
the component.
Commodore supports two types of postprocessing filters: _builtin_ filters and
_jsonnet_ filters.
Builtin filters are defined by Commodore itself.
Commodore currently provides a single builtin filter `helm_namespace` which is
intended to be used on files generated by the Kapitan helm plugin.
A component can use the `helm_namespace` filter by providing the following
filter configuration:

.component-metrics-server/postprocess/filters.yml
[source,yaml]
--
filters:
  - path: metrics-server/01_helmchart/metrics-server/templates
    type: builtin
    filter: helm_namespace
    filterargs:
      namespace: ${metrics_server:namespace}
      create_namespace: "true"
--

== Secrets Management

Commodore makes use of https://kapitan.dev/secrets/[Kapitan's secrets
management capabilities], but currently only supports references to secrets in
Vault (called "Vaultkv" in the Kapitan documentation).

Commodore takes care of generating secret reference files for any secret
references (denoted by `?{vaultkv:...}`) found in key `parameters` in  all the
classes included by the Kapitan cluster target.
Secret references can use reclass references to define dynamic defaults, as
Commodore searches for secret references in the rendered reclass inventory.

Commodore saves the generated reference files are stored in the cluster
catalog in directory `refs/`.
This directory is configured as the base path in which Kapitan searches for
reference files during compilation, allowing references in the inventory to
omit the `catalog/refs` prefix which the would have to include otherwise.

Because Commodore manages the secret files, it can guarantee that the secret
files and the catalog are always in sync.
All secret references MUST be made in the configuration parameters, otherwise
Commodore can't discover them.
Additionally, compiled manifests MUST include the secret reference in clear
text, for example by setting `stringData` for secret objects, as the secret
revealing mechanism can't find the references if they're already base64
encoded.

=== Secret file generation

Commodore generates the secret files and their contents according to specific
rules.
A Kapitan secret reference, for example `?{vaultkv:path/to/secret/thekey}`,
always refers to a key named `thekey` in a secret named `path/to/secret` in
Vault's KV back-end.
The address of the Vault instance and the name of the back-end are configurable:

[source,yaml]
--
parameters:
  secret_management:
    vault_addr: https://vault.syn.vshn.net
    # Name of the back-end (called mount in Vault)
    vault_mount: kv
--

For the secret reference mentioned above, Commodore generates a Kapitan secret
file in `catalog/refs/path/to/secret/thekey` with `path/to/secret:thekey` as
the reference to the Vault secret.

Kapitan's `vaultkv` secret engine is configured in the class `global.common`
under the dict `secret_management`.
The configuration defaults to https://vault.syn.vshn.net and a back-end with
name `kv`.
This can be overridden at any level of the inventory.
